<!DOCTYPE html>
<html>
<head>
    <titleCAPASYDIS: Interactive 3D Scatter Plot with Axis Labels</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #ffffff;
        }
        canvas {
            display: block;
        }
        #controls { /* Container for file input */
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgb(255, 255, 255);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #tooltip {
            position: absolute;
            display: none; /* Hidden by default */
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none; /* Allow clicks to pass through */
            white-space: nowrap;
            z-index: 101;
        }
        #pointInfo { /* Keep for status messages */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-top: 1px solid #ccc;
            font-size: 14px;
            color: #333;
            box-sizing: border-box; /* Include padding in width */
            z-index: 100;
            min-height: 40px; /* Ensure space is visible */
            text-align: center;
        }
         /* Style file input */
        input[type="file"] {
            border: 1px solid #ccc;
            display: inline-block;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 4px;
            background-color: #fff;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="csvFileInput">Load CSV (x,y,z,label,color): </label>
        <input type="file" id="csvFileInput" accept=".csv">
		<div><label style="color: blue;">x axis : blue</label></div>		
		<div><label style="color: red;">y axis : red</label></div>		
		<div><label style="color: green;">z axis : green</label></div>		
		
	
    </div>

    <div id="tooltip"></div>
    <div id="pointInfo">Load a CSV file to visualize data in 3D. </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import necessary Three.js modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let points = null; // Holds the THREE.Points object
        let parsedData = []; // Holds the structured data: {x, y, z, label, color}
        let tooltipElement, pointInfoElement, csvFileInput;

        // For Raycasting (interaction)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let INTERSECTED = null; // Index of the currently hovered point

        function init() {
            // Get DOM Elements
            tooltipElement = document.getElementById('tooltip');
            pointInfoElement = document.getElementById('pointInfo');
            csvFileInput = document.getElementById('csvFileInput');

            // 1. Scene Setup
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0xf0f0f0);
            scene.background = new THREE.Color("white");

            // 2. Camera Setup
            //camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 200);
            camera.position.set(15, 15, 25);
            camera.lookAt(0, 0, 0);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. OrbitControls for Interaction
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);
            controls.update();

            // 5. Axes Helper & Labels
            const axesLength = 1; // Define length for axes helper and label positioning
            const axesHelper = new THREE.AxesHelper(axesLength);
            scene.add(axesHelper); // X = blue, Y = red, Z = green

            // --- Create Axis Labels ---
            const labelOffset = 0.1; // How far beyond the axis end the label appears
            const labelScaleFactor = axesLength * 0.1; // Adjust scale based on axis length
				// X -> Y 
				// Y -> Z 
				// Z -> X 
            const xLabel = createAxisLabel('Y', new THREE.Vector3(axesLength + labelOffset, 0, 0), '#FF0000', labelScaleFactor); // Red
            const yLabel = createAxisLabel('Z', new THREE.Vector3(0, axesLength + labelOffset, 0), '#00FF00', labelScaleFactor); // Green
            const zLabel = createAxisLabel('X', new THREE.Vector3(0, 0, axesLength + labelOffset), '#0000FF', labelScaleFactor); // Blue
            scene.add(xLabel, yLabel, zLabel);
            // --- End Axis Labels ---
  
            // 6. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0.5).normalize();
            scene.add(directionalLight);

            // 7. Event Listeners
            csvFileInput.addEventListener('change', handleFileLoad, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            // --- REMOVED CLICK INFO PRINT ---
            // renderer.domElement.addEventListener('click', onMouseClick, false); // Listener kept, but action removed below
            renderer.domElement.addEventListener('click', () => {
                // Placeholder if other click actions are needed later
                // console.log("Canvas clicked");
            }, false);
            // --- END REMOVAL ---
            window.addEventListener('resize', onWindowResize, false);

             // Set threshold for Points interaction
            raycaster.params.Points.threshold = 0.5;
        }

        // --- Function to Create Axis Labels ---
        function createAxisLabel(text, position, color, scaleFactor = 1.0) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 60; // High resolution for clarity
            context.font = `Bold ${fontSize}px Arial`;

            // Measure text and set canvas size
            const metrics = context.measureText(text);
            const textWidth = metrics.width;
            // Add some padding
            canvas.width = textWidth + 20;
            canvas.height = fontSize + 20;

            // Redraw text with padding offset
            context.font = `Bold ${fontSize}px Arial`; // Reset font after resize
            context.fillStyle = color;
            context.fillText(text, 10, fontSize + 10 - 5); // x, y baseline (adjust y offset)

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true, // Use transparency
                depthTest: false, // Optional: Render labels on top
                depthWrite: false
            });

            const sprite = new THREE.Sprite(material);

			
            // Scale sprite to a reasonable size in world space
            const aspect = canvas.width / canvas.height;
            sprite.scale.set(scaleFactor * aspect, scaleFactor, 1);

            sprite.position.copy(position);

            return sprite;
        }
        // --- End Axis Label Function ---


        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) {
                console.error("No file selected.");
                pointInfoElement.textContent = "No file selected.";
                return;
            }
            if (!file.name.endsWith('.csv')) {
                 console.error("Please select a .csv file.");
                 pointInfoElement.textContent = "Error: Please select a .csv file.";
                 return;
             }


            pointInfoElement.textContent = `Loading file: ${file.name}...`;
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    parseCSV(e.target.result);
                    event.target.value = null; // Clear input
                } catch (error) {
                    console.error("Error parsing CSV:", error);
                    pointInfoElement.textContent = `Error parsing CSV: ${error.message}`;
                    clearPlot();
                }
            };

            reader.onerror = (e) => {
                console.error("Error reading file:", e);
                pointInfoElement.textContent = "Error reading file.";
            };

            reader.readAsText(file);
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split(/\r\n|\n/);
            if (lines.length < 2) {
                throw new Error("CSV file must have at least a header and one data row.");
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const requiredHeaders = ['x', 'y', 'z', 'label', 'color'];
            if (!requiredHeaders.every(h => headers.includes(h))) {
                throw new Error(`CSV must contain columns: ${requiredHeaders.join(', ')}`);
            }

            const headerMap = {};
            headers.forEach((h, i) => { headerMap[h] = i; });

            const tempData = [];
            for (let i = 1; i < lines.length; i++) {
                 if (lines[i].trim() === '') continue;

                const values = lines[i].split(',');

                 if (values.length !== headers.length) {
                    console.warn(`Skipping row ${i + 1}: Incorrect number of columns. Expected ${headers.length}, got ${values.length}.`);
                    continue;
                }

				// X -> Y 
				// Y -> Z 
				// Z -> X 
				// const x = parseFloat(values[headerMap.x]);
                // const y = parseFloat(values[headerMap.y]);
                // const z = parseFloat(values[headerMap.z]);
                const z = parseFloat(values[headerMap.x]);
                const x = parseFloat(values[headerMap.y]);
                const y = parseFloat(values[headerMap.z]);
                const label = values[headerMap.label]?.trim() || `Point ${i}`;
                const colorStr = values[headerMap.color]?.trim() || '#ffffff';

                 if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    console.warn(`Skipping row ${i + 1}: Invalid coordinate values (x, y, or z is not a number).`);
                    continue;
                 }


                tempData.push({ x, y, z, label, color: colorStr });
            }

             if (tempData.length === 0) {
                 throw new Error("No valid data points found in the CSV.");
             }


            parsedData = tempData;
            updateScatterPlot(parsedData);
            // pointInfoElement.textContent = `Loaded ${parsedData.length} points. Hover for label.`; // Update status text
            pointInfoElement.textContent = ``; // Update status text
        }

        function clearPlot() {
             if (points) {
                 scene.remove(points);
                 if (points.geometry) points.geometry.dispose();
                 if (points.material) points.material.dispose();
                 points = null;
             }
             parsedData = [];
         }


        function updateScatterPlot(data) {
            clearPlot();

            const positions = [];
            const colors = [];
            const tempColor = new THREE.Color();

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;

            data.forEach(item => {
                positions.push(item.x, item.y, item.z);
                 minX = Math.min(minX, item.x); maxX = Math.max(maxX, item.x);
                 minY = Math.min(minY, item.y); maxY = Math.max(maxY, item.y);
                 minZ = Math.min(minZ, item.z); maxZ = Math.max(maxZ, item.z);

                try {
                    tempColor.set(item.color);
                } catch (e) {
                    console.warn(`Invalid color format "${item.color}", using white.`);
                    tempColor.set(0xffffff);
                }
                colors.push(tempColor.r, tempColor.g, tempColor.b);
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeBoundingSphere();

            const material = new THREE.PointsMaterial({
                size: 0.0005, // to change the point size recommended for NR99: 0.0005 
				vertexColors: true,
                sizeAttenuation: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

             if (geometry.boundingSphere) {
                 const center = geometry.boundingSphere.center;
                 const radius = geometry.boundingSphere.radius;
                  controls.target.copy(center);
                  const distance = radius / Math.sin(THREE.MathUtils.degToRad(camera.fov / 2));
                  // Slightly adjusted camera positioning logic
                  const offset = new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance * 1.5);
                  camera.position.copy(center).add(offset);
                  camera.lookAt(center);
                  controls.update();
             }
        }

        function onMouseMove(event) {
            if (!points || parsedData.length === 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(points);

            if (intersects.length > 0) {
                const intersectIndex = intersects[0].index;
                if (INTERSECTED !== intersectIndex) {
                    INTERSECTED = intersectIndex;
                     if (parsedData[INTERSECTED]) {
                        tooltipElement.textContent = parsedData[INTERSECTED].label;
                        tooltipElement.style.display = 'block';
                     } else {
                          tooltipElement.style.display = 'none';
                          INTERSECTED = null;
                     }
                }
                tooltipElement.style.left = (event.clientX + 10) + 'px';
                tooltipElement.style.top = (event.clientY - 20) + 'px';
            } else {
                if (INTERSECTED !== null) {
                    tooltipElement.style.display = 'none';
                }
                INTERSECTED = null;
            }
        }

                function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
           renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Initialize and start animation ---
        init();
        animate();

    </script>

</body>
</html>